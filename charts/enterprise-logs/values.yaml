# -- Overrides the chart's name
nameOverride: null

# -- Overrides the chart's computed fullname
fullnameOverride: null

# -- Definition of the Docker image for Grafana Enterprise Logs
image:
  # -- The container registry to use
  registry: docker.io
  # -- The image repository to use
  repository: grafana/enterprise-logs
  # -- The version of Grafana Enterprise Logs
  tag: v1.1.0
  # -- Defines the policy how and when images are pulled
  pullPolicy: IfNotPresent
  # -- Additional image pull secrets
  pullSecrets: []

# -- Definition of the ServiceAccount for containers
serviceAccount:
  # -- Specifies whether a ServiceAccount should be created
  create: true
  # -- The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  name: null
  # -- Image pull secrets for the service account
  imagePullSecrets: []
  # -- Annotations for the service account
  annotations: {}

# Kubernetes RBAC configuration
rbac:
  # -- If enabled, a Role and a RoleBinding are created
  enabled: true
  # -- If enabled, a PodSecurityPolicy is enabled (only if rbac.enabled=true)
  pspEnabled: false

useExternalConfig: false
externalConfigName: enterprise-logs-config
externalConfigVersion: "0"

useExternalLicense: false
externalLicenseName: enterprise-logs-config
externalLicenseVersion: "0"

# In order to use Grafana Enterprise Logs features, you will need to provide the contents of your Grafana Enterprise Logs
# license, either by providing the contents of the license.jwt, or the name Kubernetes Secret that contains your license.jwt.
# To set the license contents, use the flag `--set-file 'license.contents=./license.jwt'`
license:
  contents: "NOTAVALIDLICENSE"

# -- Grafana Enterprise Logs configuration file
config:
  auth:
    type: enterprise
  auth_enabled: true
  license:
    path: "/etc/enterprise-logs/license/license.jwt"
  cluster_name: "{{ .Release.Name }}"
  admin_client:
    storage:
      type: s3
  compactor:
    shared_store: s3
    working_directory: /data/boltdb-shipper-compactor
  ingester:
    lifecycler:
      num_tokens: 512
      ring:
        replication_factor: 3
        kvstore:
          store: memberlist
  limits_config:
    reject_old_samples: true
    reject_old_samples_max_age: 168h
  ingester_client:
    grpc_client_config:
      max_recv_msg_size: 104857600
      max_send_msg_size: 104857600
  memberlist:
    abort_if_cluster_join_fails: false
    bind_port: 7946
    join_members:
      - "{{ .Release.Name }}-enterprise-logs-memberlist"
  distributor:
    ring:
      kvstore:
        store: memberlist
  querier:
    query_ingesters_within: 12h
  query_range:
    split_queries_by_interval: 24h
    align_queries_with_step: true
    cache_results: true
    results_cache:
      cache:
        memcached:
          expiration: 1h
        memcached_client:
          timeout: 1s
  schema_config:
    configs:
      - from: 2021-01-01
        store: boltdb-shipper
        object_store: aws
        schema: v11
        index:
          prefix: index_
          period: 24h
  storage_config:
    aws:
      s3: "http://enterprise-logs:supersecret@{{ .Release.Name }}-minio:9000"
      bucketnames: enterprise-logs-tsdb
      s3forcepathstyle: true
      insecure: true
    boltdb_shipper:
      active_index_directory: /var/loki/index
      cache_location: /var/loki/cache
      cache_ttl: 24h
      shared_store: s3
  ruler:
    enable_alertmanager_discovery: false
    enable_api: true
    enable_sharding: true
    ring:
      kvstore:
        store: memberlist
    rule_path: /var/loki
  frontend:
    log_queries_longer_than: 10s
  server:
    http_listen_port: 3100
    grpc_listen_port: 9095

# -- Configuration for `tokengen` target
tokengen:
  # -- Weather the job should be part of the deployment
  enable: true
  # -- Additional CLI arguments for the `tokengen` target
  extraArgs: {}
  # -- Additional Kubernetes environment
  env: []
  # -- Additional labels for the `tokengen` Job
  labels: {}
  # -- Additional annotations for the `tokengen` Job
  annotations: {}
  # -- Additional volumes for Pods
  extraVolumes: []
  # -- Additional volume mounts for Pods
  extraVolumeMounts: []

# -- Configuration for the `admin-api` target
adminApi:
  # -- Define the amount of instances
  replicas: 1
  # -- Additional CLI arguments for the `admin-api` target
  extraArgs: {}
  # -- Additional labels for the `admin-api` Deployment
  labels: {}
  # -- Additional annotations for the `admin-api` Deployment
  annotations: {}

  service:
    # -- Additional labels for the `admin-api` Service
    labels: {}
    # -- Additional annotations for the `admin-api` Service
    annotations: {}

  securityContext: {}
  strategy:
    type: RollingUpdate

  env: []

  persistence:
    subPath:

  livenessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 45

  readinessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 45

  # -- Request and limit Kubernetes resources
  # -- Values are defined in small.yaml and large.yaml
  resources: {}

  initContainers: []
  extraContainers: []

  # -- Additional volumes for Pods
  extraVolumes: []
  # -- Additional volume mounts for Pods
  extraVolumeMounts: []

  # -- Affinity for admin-api Pods
  affinity: {}
  # -- Node selector for admin-api Pods
  nodeSelector: {}
  # -- Tolerations for admin-api Pods
  tolerations: []
  # -- Grace period to allow the admin-api to shutdown before it is killed
  terminationGracePeriodSeconds: 60

# -- Configuration for the `gateway` target
gateway:
  # -- Define the amount of instances
  replicas: 1
  # -- Additional CLI arguments for the `gateway` target
  extraArgs: {}
  # -- Additional labels for the `gateway` Pod
  labels: {}
  # -- Additional annotations for the `gateway` Pod
  annotations: {}

  service:
    # -- Additional labels for the `gateway` Service
    labels: {}
    # -- Additional annotations for the `gateway` Service
    annotations: {}

  # If you want to use your own proxy URLs, set this to false.
  useDefaultProxyURLs: true

  securityContext: {}
  strategy:
    type: RollingUpdate

  livenessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 45

  readinessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 45

  # -- Request and limit Kubernetes resources
  # -- Values are defined in small.yaml and large.yaml
  resources: {}

  env: []

  persistence:
    subPath:

  initContainers: []
  extraContainers: []

  # -- Additional volumes for Pods
  extraVolumes: []
  # -- Additional volume mounts for Pods
  extraVolumeMounts: []

  # -- Affinity for gateway Pods
  affinity: {}
  # -- Node selector for gateway Pods
  nodeSelector: {}
  # -- Tolerations for gateway Pods
  tolerations: []
  # -- Grace period to allow the gateway to shutdown before it is killed
  terminationGracePeriodSeconds: 60


# -- Configuration for the `compactor` target
compactor:
  # -- Define the amount of instances
  replicas: 1
  # -- Additional CLI arguments for the `compactor` target
  extraArgs: {}
  # -- Additional labels for the `compactor` Pod
  labels: {}
  # -- Additional annotations for the `compactor` Pod
  annotations: {}

  service:
    # -- Additional labels for the `compactor` Service
    labels: {}
    # -- Additional annotations for the `compactor` Service
    annotations: {}

  securityContext: {}
  strategy:
    type: RollingUpdate

  # -- Request and limit Kubernetes resources
  # -- Values are defined in small.yaml and large.yaml
  resources: {}

  persistentVolume:
    # If true compactor will create/use a Persistent Volume Claim
    # If false, use emptyDir
    #
    enabled: true
    # compactor data Persistent Volume Claim annotations
    #
    annotations: {}
    # compactor data Persistent Volume access modes
    # Must match those of existing PV or dynamic provisioner
    # Ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
    #
    accessModes:
      - ReadWriteOnce
    # compactor data Persistent Volume size
    #
    size: 2Gi
    # Subdirectory of compactor data Persistent Volume to mount
    # Useful if the volume's root directory is not empty
    #
    subPath: ''
    # compactor data Persistent Volume Storage Class
    # If defined, storageClassName: <storageClass>
    # If set to "-", storageClassName: "", which disables dynamic provisioning
    # If undefined (the default) or set to null, no storageClassName spec is
    #   set, choosing the default provisioner.  (gp2 on AWS, standard on
    #   GKE, AWS & OpenStack)
    #
    # storageClass: "-"

  livenessProbe:
    failureThreshold: 20  # 10 minutes failure threshold
    httpGet:
      path: /ready
      port: http-metrics
      scheme: HTTP
    initialDelaySeconds: 180
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 1

  readinessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 60

  env: []

  initContainers: []
  extraContainers: []

  # -- Additional volumes for Pods
  extraVolumes: []
  # -- Additional volume mounts for Pods
  extraVolumeMounts: []

  # -- Affinity for compactor Pods
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: target
                  operator: In
                  values:
                    - compactor
            topologyKey: 'kubernetes.io/hostname'
  # -- Node selector for compactor Pods
  nodeSelector: {}
  # -- Tolerations for compactor Pods
  tolerations: []
  # -- Grace period to allow the compactor to shutdown before it is killed
  terminationGracePeriodSeconds: 300


# Configuration for `loki-distributed` child chart
loki-distributed:
  nameOverride: enterprise-logs

  compactor:
    # -- Compactor is defined in parent chart
    enabled: false
  gateway:
    # -- Gateway is defined in parent chart
    enabled: false
  ruler:
    enabled: true
    extraVolumes:
      # -- Create license volume from license secret
      - name: license
        secret:
          secretName: enterprise-logs-license
    extraVolumeMounts:
      # -- Mount the license volume
      - name: license
        mountPath: /etc/enterprise-logs/license
  ingester:
    enabled: true
    extraVolumes:
      # -- Create license volume from license secret
      - name: license
        secret:
          secretName: enterprise-logs-license
    extraVolumeMounts:
      # -- Mount the license volume
      - name: license
        mountPath: /etc/enterprise-logs/license
  distributor:
    enabled: true
    extraVolumes:
      # -- Create license volume from license secret
      - name: license
        secret:
          secretName: enterprise-logs-license
    extraVolumeMounts:
      # -- Mount the license volume
      - name: license
        mountPath: /etc/enterprise-logs/license
  querier:
    enabled: true
    extraVolumes:
      # -- Create license volume from license secret
      - name: license
        secret:
          secretName: enterprise-logs-license
    extraVolumeMounts:
      # -- Mount the license volume
      - name: license
        mountPath: /etc/enterprise-logs/license
  queryFrontend:
    enabled: true
    extraVolumes:
      # -- Create license volume from license secret
      - name: license
        secret:
          secretName: enterprise-logs-license
    extraVolumeMounts:
      # -- Mount the license volume
      - name: license
        mountPath: /etc/enterprise-logs/license
  tableManager:
    enabled: true
    extraVolumes:
      # -- Create license volume from license secret
      - name: license
        secret:
          secretName: enterprise-logs-license
    extraVolumeMounts:
      # -- Mount the license volume
      - name: license
        mountPath: /etc/enterprise-logs/license
  loki:
    config: null
    existingSecretForConfig: enterprise-logs-config
    image:
      registry: docker.io
      repository: grafana/enterprise-logs
      tag: v1.1.0
      pullPolicy: IfNotPresent
      pullSecrets: []


# Configuration for `minio` child chart
minio:
  enabled: true
  accessKey: enterprise-logs
  secretKey: supersecret
  buckets:
    - name: enterprise-logs-tsdb
      policy: none
      purge: false
    - name: enterprise-logs-admin
      policy: none
      purge: false
    - name: enterprise-logs-ruler
      policy: none
      purge: false
  persistence:
    size: 5Gi
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
